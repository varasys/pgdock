#!/usr/bin/env bash

export version="v0.1.1"

help_header () {
	echo "${BOLD}pgdock (${version}) https://github.com/varasys/pgdock${NORMAL}"
	echo "    Wrapper script for postgres and pgadmin4 running in docker"
	echo
}

source_env () {
	# parse env file supplied as ${1}
	# if directory check for Environment file in the directory
	# if a file is found it is sourced and change dir to file directory
	env_file=${1}
	case ${env_file} in
		--) unset env_file;;
		.)  env_file="./"
	esac
	[ ! ${env_file} ] && [ -r "Environment" ] && env_file="./Environment"
	if [[ "${env_file}" =~ / ]] && [ -d "${env_file}" ] && [ -r "${env_file}/Environment" ]; then
		env_file="${env_file}/Environment"
	fi
	if [[ "${env_file}" =~ / ]]; then
		if [ -r "${env_file}" ]; then
			echo "Sourcing environment file: ${env_file}"
			. ${env_file}
			cd $(dirname ${env_file})
		else
			echo "Invalid environment file: ${env_file}" 1>&2
			exit 1
		fi
	else
		echo "No environment file supplied"
	fi
}
	
case $(basename ${0}) in
	pgdock)
		apps=("postgres" \
			"pgadmin4" \
			"pg_archivecleanup" \
			"pg_basebackup" \
			"pg_config" \
			"pg_controldata" \
			"pg_ctl" \
			"pg_dump" \
			"pg_dumpall" \
			"pg_isready" \
			"pg_receivexlog" \
			"pg_recvlogical" \
			"pg_resetxlog" \
			"pg_restore" \
			"pg_rewind" \
			"pg_standby" \
			"pg_test_fsync" \
			"pg_test_timing" \
			"pg_upgrade" \
			"pg_xlogdump" \
			"psql")

			show_help () {
				help_header
				cat <<-EOF
					Usage:
					    pgdock ( -i | -u ) bin_dir
					    pgdock (-h | -v )

					Options:
					    -i ) install script and symlinks to bin_dir
					    -u ) uninstall script and symlinks from bin_dir
					    -h) show this help
					    -v) print the version (${version}) to stdout

					pgdock works be creating symlinks to the pgdock script. When the
					script is executed through a symlink it refers to the \${0} environment
					variable to see what name it was called as.

					\`pgdock -i install\` installs the script and symlinks in the
					bin_dir. The script will act according to the name of the link used
					to call it.

					Type "postgres -h" or "pgadmin4 -h" to get help on running the postgres
					and pgadmin4 commands.

					All other commands function normally, except require the name of a running
					container as the first argument. For example, if there is a container named
					"my_db" running postgres, the command "postgres my_db psql -d database1"
					will run psql in the container and pass it the command line argument
					"-d database1".

					pgdock provides the following:
EOF
				echo ${apps[@]} | tr ' ' "\n" | sort | awk '{print "  - ", $0}'
				echo
		}
		while getopts ":iuhv" flag; do
			case ${flag} in
				i ) install="true";;
				u ) uninstall="true";;
				h ) show_help; exit 0;;
				\? ) echo "Invalid option: -${OPTARG}" 1>&2; show_help1>&2; exit 1;;
			esac
		done
		shift $((OPTIND-1))
		target=${1}
		if ! [ -d "${target}" ]; then
			echo "Invalid directory" 1>&2
			show_help 1>&2
			exit 1
		fi
		if [ ${install} ]; then
			echo "Installing ${target}/pgdock"
			[ ! -e "${target}/pgdock" ] \
			&& cp ${0} "${target}/pgdock" \
			&&	echo "installed ${target}/pgdock" \
			||	echo "skipping existing ${target}/pgdock" 1>&2
			for app in ${apps[@]}; do
				[ ! -e "${target}/${app}" ] \
				&& ln -s pgdock ${target}/${app} \
				&& echo "    installed symlink ${target}/${app}" \
				|| echo "    skipping existing ${target}/${app}" 1>&2
			done
		fi
		if [ ${uninstall} ]; then
			echo "Uninstalling ${target}/pgdock"
			for app in $(find ${target} -lname "pgdock"); do
				rm ${app} && echo "    deleted symlink ${app}"
			done
			[ -e "${target}/pdock" ] && rm ${target}/pgdock && echo "deleted ${target}/pgdock"
		fi
		;;
	postgres)
		export PGD_IMAGE=${PGD_IMAGE:-"postgres"}
		export PGD_IMAGE_TAG=${PGD_IMAGE_TAG:-"9.6.4-alpine"}
		export PGD_CONTAINER_PORT=${PGD_CONTAINER_PORT:-"5432"}

		show_help () {
			help_header
			cat <<-EOF
				Usage:
				    postgres [-acdehpv] [env | --] [pg_options]

				Where:
				    env is an optional file, or directory containing a file called
				    Environment, with environment variables to configure the cluster.
				    When run without an Environment file the container name will be
				    "${PGD_IMAGE}-${PGD_IMAGE_TAG//./_}", data will be persisted in a docker volume
				    called "${PGD_IMAGE}-${PGD_IMAGE_TAG//./_}", and no host ports will be exposed.

				Options:
				    -a) arguments to pass through to docker (as a single string)
					-c) run debug console (load shell instead of postgres)
				    -d) run in background (daemonize)
				    -h) show this help
				    -p) port_no) expose postgres on host port_no (ie. -p "0.0.0.0:5050")
				    -i) initialize new cluster directory at env
				    -v) print the version (${version}) to stdout

				The following list shows the available environment variables and
				their default values.
EOF
			env | grep "PGD_" | sort | awk '{print "    ", $0}'
			echo
		}

		initdb () {
			[ -d "${1}" ] || mkdir ${1}
			cd ${1}
			if [ -s "Environment" ]; then
				echo "Error: $1/Environment already exists" 1>&2
				exit 1
			fi
			cat > Environment <<-EOF
				# generated by pgdock ${version}
				# host paths are relative to the location of this file
				PGD_CONTAINER="$(basename $(pwd))"
				PGD_HOST_PORT="5432"
				PGD_CONTAINER_CONF_FILE="/etc/postgresql/postgresql.conf"
				PGD_HOST_DATA_DIR="./data"
				PGD_HOST_CONF_DIR="./conf"
				PGD_HOST_XLOG_DIR="./pg_xlog"
EOF
			mkdir -p data conf pg_xlog
			ln -s /var/lib/postgresql/data/postgresql.conf conf/
		}

		while getopts ":a:cdhi:p:v" flag; do
			case ${flag} in
				a ) user_args=${OPTARG};;
				c ) docker_mode="-ti --entrypoint=ash"; docker_cmd="--login";;
				d ) docker_mode="-d";;
				h ) show_help; exit 0;;
				p ) port_arg=${OPTARG};;
				i ) initdb ${OPTARG}; exit 0;;
				v ) echo ${version}; exit 0;;
				\? ) echo "Invalid option: ${OPTARG}" 1>&2; show_help; exit 1;;
			esac
		done
		arg_count=$((OPTIND-1))
		[ "${!arg_count}" = "--" ] && shift $((arg_count-1)) || shift ${arg_count}
		source_env ${1}
		shift
		[ ! ${PGD_CONTAINER} ] && PGD_CONTAINER=${PGD_CONTAINER:-"${PGD_IMAGE}-${PGD_IMAGE_TAG//./_}"}
		if  [ ${PGD_HOST_DATA_DIR} ]; then
			if [ ${PGD_HOST_DATA_DIR} = "." ] || [[ ${PGD_HOST_DATA_DIR} =~ / ]]; then
				mkdir -p ${PGD_HOST_DATA_DIR} && PGD_HOST_DATA_DIR=$(cd ${PGD_HOST_DATA_DIR}; pwd)
			fi
			PGD_HOST_DATA_DIR="-v ${PGD_HOST_DATA_DIR}:/var/lib/postgresql/data"
		else
			PGD_HOST_DATA_DIR="-v ${PGD_CONTAINER}:/var/lib/postgresql/data"
		fi
		if  [ ${PGD_HOST_CONF_DIR} ]; then
			if [ ${PGD_HOST_CONF_DIR} = "." ] || [[ ${PGD_HOST_CONF_DIR} =~ / ]]; then
				mkdir -p ${PGD_HOST_CONF_DIR} && PGD_HOST_CONF_DIR=$(cd ${PGD_HOST_CONF_DIR}; pwd)
			fi
			PGD_HOST_CONF_DIR="-v ${PGD_HOST_CONF_DIR}:/etc/postgresql"
		fi
		if  [ ${PGD_HOST_XLOG_DIR} ]; then
			if [ ${PGD_HOST_XLOG_DIR} = "." ] || [[ ${PGD_HOST_XLOG_DIR} =~ / ]]; then
				mkdir -p ${PGD_HOST_XLOG_DIR} && PGD_HOST_XLOG_DIR=$(cd ${PGD_HOST_XLOG_DIR}; pwd)
			fi
			PGD_HOST_XLOG_DIR="-v ${PGD_HOST_XLOG_DIR}:/var/lib/postgresql/pg_xlog \
				-e POSTGRES_INITDB_XLOGDIR=/var/lib/postgresql/pg_xlog"
		fi
		[ ${port_arg} ] || [ ${PGD_HOST_PORT} ] && PGD_HOST_PORT="-p ${port_arg:-${PGD_HOST_PORT}}:${PGD_CONTAINER_PORT}"
		docker_args="--rm \
			${docker_mode} \
			--name ${PGD_CONTAINER} \
			--hostname ${PGD_CONTAINER} \
			${PGD_HOST_DATA_DIR} \
			${PGD_HOST_CONF_DIR} \
			${PGD_HOST_XLOG_DIR} \
			${PGD_HOST_PORT} \
			-e POSTGRES_INITDB_ARGS='--data-checksums'"

		postgres_args="--port=${PGD_CONTAINER_PORT}"
		[ ${PGD_CONTAINER_CONF_FILE} ] && postgres_args="${postgres_args} --config_file=${PGD_CONTAINER_CONF_FILE}"

		cmd="docker run ${docker_args} ${user_args} ${PGD_IMAGE}:${PGD_IMAGE_TAG} ${docker_cmd} ${postgres_args} ${@}"
		echo ${cmd}
		exec ${cmd}
		;;
	pgadmin4)
		export PGA_IMAGE=${PGA_IMAGE:-"pgadmin4"}
		export PGA_IMAGE_TAG=${PGA_IMAGE_TAG:-"1.6"}
		export PGA_CONTAINER=${PGA_CONTAINER:-"${PGA_IMAGE}-${PGA_IMAGE_TAG//./_}"}
		export PGA_HOST_PORT=
		export PGA_CONTAINER_PORT=${PGA_CONTAINER_PORT:-"5050"} TODO implement this
		export PGA_DATA_DIR=${PGA_DATA_DIR:-${PGA_CONTAINER}}
		export PGA_PYTHON_IMAGE=${PGA_PYTHON_IMAGE:-"python"}
		export PGA_PYTHON_IMAGE_TAG=${PGA_PYTHON_IMAGE_TAG:-"3.5.2-alpine"}
		export PGA_WHEEL=${PGA_WHEEL:-"pgadmin4-${PGA_IMAGE_TAG}-py2.py3-none-any.whl"}
		export PGA_WHEEL_URL=${PGA_WHEEL_URL:-"https://ftp.postgresql.org/pub/pgadmin/pgadmin4/v${PGA_IMAGE_TAG}/pip/${PGA_WHEEL}"}

		show_help () {
			help_header
			cat <<-EOF
				Usage:
				    pgadmin4 [-abcdfr] [env]

				Options:
				    -a) arguments to pass through to docker (as a single string)
				    -b) build docker image (delete first if existing)
				    -c) run debug console (load shell instead of pgadmin4)
				    -d) run in background (daemonize)
				    -p port_no) expose pgadmin4 on host port_no (ie. -p "0.0.0.0:5050")
				    -r) reset pgadmin4 data (delete pgadmin4 docker volume)
				    -h) show this help
				    -v) print the version (${version}) to stdout

				The script automatically creates a docker image called if it doesn't
				already exist. Base images and packages are downloaded as needed. If

				On the first run the user will be prompted for an admin user
				name and password. That information and other configuration
				is persisted in a docker volume called ${PGA_CONTAINER}. Use the
				-r flag to delete/reset this volume on start.

				The following list shows the available environment variables and
				their default values. In theory, these environment variables can be
				changed to change the pgadmin4 and python versions used to build the
				docker image.
		EOF
				env | grep "PGA_" | sort | awk '{print "    ", $0}'
				echo
		}

		while getopts ":a:bcdhp:rv" flag
		do
			case ${flag} in
				a ) user_args=${OPTARG};;
				b ) [ $(docker rmi -f ${PGA_IMAGE}:${PGA_IMAGE_TAG}) ] && echo "Deleted ${PGA_IMAGE}:${PGA_IMAGE_TAG} docker image";;
				c ) docker_mode="-ti --entrypoint=ash"; docker_cmd="--login";;
				d ) docker_mode="-d";;
				h ) show_help; exit 0;;
				p ) PGA_HOST_PORT=${OPTARG};;
				r ) [ $(docker volume rm -f ${PGA_DATA_DIR}) ] && echo "Deleted pgadmin4 docker volume";;
				v ) echo ${version} && exit 0;;
				\? ) echo "Invalid option: $OPTARG" 1>&2; show_help; exit 1;;
			esac
		done
		shift $((OPTIND-1))
		source_env ${1}
		if [ ! $(docker images -q ${PGA_IMAGE}:${PGA_IMAGE_TAG}) ]; then
			echo "Building ${PGA_IMAGE}:${PGA_IMAGE_TAG} docker image"
			docker build -t ${PGA_IMAGE}:${PGA_IMAGE_TAG} - <<-EOF
				FROM ${PGA_PYTHON_IMAGE}:${PGA_PYTHON_IMAGE_TAG}

				RUN apk --no-cache --update --upgrade add --virtual .tmp build-base curl
				RUN apk --no-cache add --upgrade postgresql-dev

				RUN curl -L ${PGA_WHEEL_URL} > ${PGA_WHEEL}
				RUN pip install ${PGA_WHEEL} && rm ${PGA_WHEEL}
				RUN apk del --purge .tmp

				WORKDIR /usr/local/lib/python3.5/site-${PGA_WHEEL}/pgadmin4
				RUN echo "DEFAULT_SERVER = '0.0.0.0'" >> config_local.py
				RUN echo "DATA_DIR = '/var/lib/pgadmin4'" >> config_local.py

				RUN mkdir /var/lib/pgadmin4
				RUN chown nobody:nobody /var/lib/pgadmin4
				VOLUME ${PGA_DATA_DIR}
				ENV HOME /var/lib/pgadmin4

				EXPOSE 5050
				
				ENTRYPOINT ["/usr/local/bin/python"]
				CMD ["/usr/local/lib/python3.5/site-packages/pgadmin4/pgAdmin4.py"]
		EOF
			echo "\nFinished building ${PGA_IMAGE}:${PGA_IMAGE_TAG} docker image"
			docker images ${PGA_IMAGE}:${PGA_IMAGE_TAG}
			echo
		fi

		docker_args="--rm \
					--name=${PGA_CONTAINER} \
					--hostname=${PGA_CONTAINER} \
					-v ${PGA_DATA_DIR}:/var/lib/pgadmin4"
		[ ${PGA_HOST_PORT} ] && docker_args="${docker_args} -p ${PGA_HOST_PORT}:5050"

		cmd="docker run ${docker_mode:-"-ti"} ${docker_args} ${user_args} ${PGA_IMAGE}:${PGA_IMAGE_TAG} ${docker_cmd}"
		echo ${cmd}
		exec ${cmd}
		;;
	*) # try and execute the command on the container
		command=$(basename ${0})
		name=${1}
		shift
		[ -t 0 ] && isterm="t"
		exec docker exec -u postgres -${isterm}i ${name} ${command} ${@}
        ;;
esac
